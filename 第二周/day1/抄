1.预解释:
    在当前作用域下,代码执行之前,对带var关键字和带function关键字的进行提前声明和定义
    声明:在内存空间里存个变量 例如:var num;
    定义:不仅存了变量,还有值 例如:var num  = 10;
    注:
      对var关键字的是进行声明
      对function关键字的进行定义
  函数执行4步骤:
    1.开辟一个私有的作用域
    2.形参赋值
    3.预解释
    4.代码从上往下执行

2.作用域
  全局作用域:浏览器加载页面时形成 谁都可以访问 全局变量
  私有作用域:函数运行时形成 只有自己可以访问 私有变量:形参和带var关键字的
  查找变量的顺序:
  1.若是私有的,则就是它,就是函数体内的私有变量
  2.若不是,则往上级作用域查找,若没有,则继续往上级找到,直到找到,若到全局也没找到,则报错
  注:上级作用域跟函数在哪定义有关,跟函数在哪执行无关

  3.无节操之预解释
    1)只对等号左边进行预解释
    2)return 后面不进行预解释,但是return 下面的预解释
    3)不管条件是否成立,对带var关键字的预解释,对function关键字,ie下预解释,标准浏览器只声明不定义
    4)重名变量不会重复声明,但是可以重复定义
    5)自执行函数不预解释,定义+执行一步到位完成

  4.作用域销毁
    私有作用域:一般情况下,函数运行结束后,作用域会立即销毁
    不销毁情况:
          1)不立即销毁:
            函数执行后返回一个被需要执行的函数,这时不立即销毁,等返回的这个小函数执行完了之后,才能被销毁
          2)不销毁:
            函数运行后的作用域,若里面的东西被外界占用时,则作用域不销毁

  5.this
  1)看方法名前面是否有点,点前面是谁this就是谁,没有则this是window
  2)自执行函数里的this是window
  3)事件驱动函数里的this是当前绑定的元素
  4)构造函数里的this是当前实例

   6.构造函数的注意点:
      1.通过new去执行函数,这个函数称为构造函数
      2.构造函数里的this指的是实例
      3.this.xxx 所有的属性和方法是实例私有的属性和方法
      4.new Person()已经创建了实例,只是是一个匿名实例
      5.若不需要传参数,运行时()可省略-> new Person;
      6.通过var定义的变量和实例无关,实例只跟this.xxx有关

   7.原型基础知识:
        1.每个函数上都有个prototype属性,prototype是个对象
        2.prototype对象上有个属性叫constructor,它指向当前的构造函数
        3.每个对象上都有个__proto__,它指向实例所属类的原型

   8.属性和方法查找的顺序
        1.若自己实例有,则表示是私有的,不会再继续查找
        2.若没有,则通过__proto__去当前实例所属类的原型上查找,找到了则用原型上的
        3.若还没有找到,继续通过__proto__往父类找...直到找到Object类的原型上,若都没找到则返回undefined
        Object类是基类,其他类是派生类
        __proto__一级一级往父类上查找,则形成了原型链
        __proto__是实现原型继承的关键