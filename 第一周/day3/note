1.预解释:
    在当前作用域下,代码执行之前,对带var关键字和带function关键字的进行提前声明和定义
  声明:在内存空间里存个变量 例如:var num;
  定义:不仅存了变量,还有值 例如:var num  = 10;
  注:
  对var关键字的是进行声明
  对function关键字的进行定义

  函数定义3步骤:
  1.开辟一个内存空间,假设引用地址ooffxx
  2.函数体体里的内容以字符串形式存在里面
  3.把引用地址赋给函数名,这样函数名代表了整个函数

  函数执行4步骤:
  1.开辟一个私有的作用域
  2.形参赋值
  3.预解释
  4.代码从上往下执行

  在全局作用域下:带var和不带var区别
  共同点:都是window的属性
  不同点:带var预解释,不带var的不预解释

2.作用域
  全局作用域:浏览器加载页面时形成 谁都可以访问 全局变量
  私有作用域:函数运行时形成 只有自己可以访问 私有变量:形参和带var关键字的
  查找变量的顺序:
  1.若是私有的,则就是它,就是函数体内的私有变量
  2.若不是,则往上级作用域查找,若没有,则继续往上级找到,直到找到,若到全局也没找到,则报错
  注:上级作用域跟函数在哪定义有关,跟函数在哪执行无关

3.无节操之预解释
  1)只对等号左边进行预解释
  2)return 后面不进行预解释,但是return 下面的预解释
  3)不管条件是否成立,对带var关键字的预解释,对function关键字,ie下预解释,标准浏览器只声明不定义
  4)重名变量不会重复声明,但是可以重复定义
  5)自执行函数不预解释,定义+执行一步到位完成

4.闭包
  函数运行时形成一个私有的作用域,是浏览器内在的一种机制
  1.封装性
  2.避免冲突

5.内存释放
栈内存:全局作用域和私有作用域
      存储值类型的数据
      特点:空间小,速度快
全局作用域:关闭页面或关闭浏览器
私有作用域:一般情况下,函数运行结束后,作用域会立即销毁
不销毁情况:
      1)不立即销毁:
        函数执行后返回一个被需要执行的函数,这时不立即销毁,等返回的这个小函数执行完了之后,才能被销毁
      2)不销毁:
        函数运行后的作用域,若里面的东西被外界占用时,则作用域不销毁

堆内存:存储引用类型的数据 例如:对象,函数  变量 = null;
      特点:空间大,速度慢
      堆内存的引用地址被其他变量占用,则不销毁,若想销毁,把变量设成null,相当于设成空指针,这样浏览器空闲时,会回收变量,以释放这块内存,这称为垃圾回收机制

i++与++i的区别
++i:先++,后运算
i++:先运算,后++(后累加的和运算没有关系,是自身累加)





